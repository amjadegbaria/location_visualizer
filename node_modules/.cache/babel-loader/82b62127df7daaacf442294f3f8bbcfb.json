{"ast":null,"code":"/**\n * Calculate a point transformed with an affine matrix\n * @param matrix {Matrix} Affine Matrix\n * @param  point {Point} Point\n * @returns {Point} Point\n */\nexport function applyToPoint(matrix, point) {\n  return Array.isArray(point) ? [matrix.a * point[0] + matrix.c * point[1] + matrix.e, matrix.b * point[0] + matrix.d * point[1] + matrix.f] : {\n    x: matrix.a * point.x + matrix.c * point.y + matrix.e,\n    y: matrix.b * point.x + matrix.d * point.y + matrix.f\n  };\n}\n/**\n * Calculate an array of points transformed with an affine matrix\n * @param matrix {Matrix} Affine Matrix\n * @param points {Point[]} Array of point\n * @returns {Point[]} Array of point\n */\n\nexport function applyToPoints(matrix, points) {\n  return points.map(point => applyToPoint(matrix, point));\n}","map":{"version":3,"sources":["C:/Users/AMJADE/Rabea/new-app/node_modules/transformation-matrix/src/applyToPoint.js"],"names":["applyToPoint","matrix","point","Array","isArray","a","c","e","b","d","f","x","y","applyToPoints","points","map"],"mappings":"AAAA;;;;;;AAMA,OAAO,SAASA,YAAT,CAAuBC,MAAvB,EAA+BC,KAA/B,EAAsC;AAC3C,SAAOC,KAAK,CAACC,OAAN,CAAcF,KAAd,IAAuB,CAC5BD,MAAM,CAACI,CAAP,GAAWH,KAAK,CAAC,CAAD,CAAhB,GAAsBD,MAAM,CAACK,CAAP,GAAWJ,KAAK,CAAC,CAAD,CAAtC,GAA4CD,MAAM,CAACM,CADvB,EAE5BN,MAAM,CAACO,CAAP,GAAWN,KAAK,CAAC,CAAD,CAAhB,GAAsBD,MAAM,CAACQ,CAAP,GAAWP,KAAK,CAAC,CAAD,CAAtC,GAA4CD,MAAM,CAACS,CAFvB,CAAvB,GAGH;AACFC,IAAAA,CAAC,EAAEV,MAAM,CAACI,CAAP,GAAWH,KAAK,CAACS,CAAjB,GAAqBV,MAAM,CAACK,CAAP,GAAWJ,KAAK,CAACU,CAAtC,GAA0CX,MAAM,CAACM,CADlD;AAEFK,IAAAA,CAAC,EAAEX,MAAM,CAACO,CAAP,GAAWN,KAAK,CAACS,CAAjB,GAAqBV,MAAM,CAACQ,CAAP,GAAWP,KAAK,CAACU,CAAtC,GAA0CX,MAAM,CAACS;AAFlD,GAHJ;AAOD;AAED;;;;;;;AAMA,OAAO,SAASG,aAAT,CAAwBZ,MAAxB,EAAgCa,MAAhC,EAAwC;AAC7C,SAAOA,MAAM,CAACC,GAAP,CAAWb,KAAK,IAAIF,YAAY,CAACC,MAAD,EAASC,KAAT,CAAhC,CAAP;AACD","sourcesContent":["/**\n * Calculate a point transformed with an affine matrix\n * @param matrix {Matrix} Affine Matrix\n * @param  point {Point} Point\n * @returns {Point} Point\n */\nexport function applyToPoint (matrix, point) {\n  return Array.isArray(point) ? [\n    matrix.a * point[0] + matrix.c * point[1] + matrix.e,\n    matrix.b * point[0] + matrix.d * point[1] + matrix.f\n  ] : {\n    x: matrix.a * point.x + matrix.c * point.y + matrix.e,\n    y: matrix.b * point.x + matrix.d * point.y + matrix.f\n  }\n}\n\n/**\n * Calculate an array of points transformed with an affine matrix\n * @param matrix {Matrix} Affine Matrix\n * @param points {Point[]} Array of point\n * @returns {Point[]} Array of point\n */\nexport function applyToPoints (matrix, points) {\n  return points.map(point => applyToPoint(matrix, point))\n}\n"]},"metadata":{},"sourceType":"module"}